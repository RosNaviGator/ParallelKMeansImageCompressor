#include <opencv2/opencv.hpp>
#include <iostream>
#include <vector>
#include <string>
#include <fstream>
#include <sstream>
#include <vector>
#include <iostream>
#include <fstream>
#include <sstream>
#include <zlib.h>

int main()
{
    std::string path;
    std::cout << "##########################################################################################" << std::endl;
    std::cout << "#                                                                                        #" << std::endl;
    std::cout << "#                            Parallel Kmeans Images Decoder                              #" << std::endl;
    std::cout << "#                                                                                        #" << std::endl;
    std::cout << "##########################################################################################" << std::endl<< std::endl;
    std::cout << "------------------------------------------------------------------------------------------" << std::endl;
    std::cout << "| This is the Decoder to decode the .kc file generated by the Encoder                    |" << std::endl;
    std::cout << "| If you havent already compress a file by the Encoder this Decoder is not so usefull    |" << std::endl;
    std::cout << "------------------------------------------------------------------------------------------" << std::endl<< std::endl;
    std::cout << "Please enter the global path of the .kc file you want to decode" << std::endl;
    std::cout << "--> ";
    std::getline(std::cin, path); 
    std::cout << std::endl;
    std::string answer = "d";
    while (answer != "y" && answer != "n")
    {
        std::cout << "Do you want to save a copy .jpg of your Compressed Image? [y/n]"<< std::endl;
        std::cout << "--> ";
        std::cin >> answer;
    }
    int count = 0;
    int k = 0;
    double width = 0;
    double height = 0;

    gzFile fileComp = gzopen(path.c_str(), "rb");
    if (!fileComp)
    {
        std::cerr << "Error opening the file." << std::endl;
        return 1;
    }

    std::stringstream decompressedData;

    char buffer[1024];
    int bytesRead;


    while ((bytesRead = gzread(fileComp, buffer, sizeof(buffer))) > 0) {
        decompressedData.write(buffer, bytesRead);
    }

    // Close the compressed file
    gzclose(fileComp);

    // Get the decompressed data as a string
    std::string result = decompressedData.str();

    std::istringstream outputFile(result);

    std::string line;
    std::vector<std::vector<double>> clustersColors;
    std::vector<cv::Vec3b> pixels;
    while (std::getline(outputFile, line))
    {
        
        if (count == 0)
        {
            std::istringstream iss(line);
            std::string token;
            std::getline(iss, token, ',');
            width = std::stoi(token);
            std::getline(iss, token, ',');
            height = std::stoi(token);
            std::getline(iss, token, ',');
            k = std::stoi(token);
        }else if(count < k+1)
        {
            std::istringstream iss(line);
            std::vector<std::string> values;
            std::string value;
            while (getline(iss, value, ','))
            {
            values.push_back(value);
            }
            std::vector<double> features;
            for (size_t i = 0; i < values.size(); i++)
            {
                features.push_back(std::stod(values[i]));
            }
            clustersColors.push_back(features);
        }else if(count > k){
            std::istringstream iss(line);
            std::string cluster;
            std::getline(iss, cluster);
            int clusterint = std::stoi(cluster);
            pixels.emplace_back(clustersColors.at(clusterint).at(0), clustersColors.at(clusterint).at(1), clustersColors.at(clusterint).at(2));
        }
        count = count + 1;
    }

    cv::Mat imageCompressed = cv::Mat(height, width, CV_8UC3);
    for(int y = 0 ; y < height ; y++)
    {
        for (int x = 0 ; x < width ; x++)
        {
            imageCompressed.at<cv::Vec3b>(y, x) = pixels.at(y * width + x);
        }
    }
    if(answer == "y")
    {
        if (path.length() >= 3) {
        // Rimuovi gli ultimi 3 caratteri dalla stringa
        path.erase(path.length() - 3);
        }
        std::string outputPath = path + ".jpg";
        cv::imwrite(outputPath, imageCompressed);
    }
    cv::imshow("Compressed Image", imageCompressed);
    cv::waitKey(0);
    
    return 0;
}